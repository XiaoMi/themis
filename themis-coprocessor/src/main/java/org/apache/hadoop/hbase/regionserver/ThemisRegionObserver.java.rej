--- themis-coprocessor/src/main/java/org/apache/hadoop/hbase/regionserver/ThemisRegionObserver.java
+++ /dev/null
@@ -1,187 +0,0 @@
-package org.apache.hadoop.hbase.regionserver;
-
-import java.io.IOException;
-import java.util.Collections;
-import java.util.Iterator;
-import java.util.List;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.apache.hadoop.hbase.KeyValue;
-import org.apache.hadoop.hbase.KeyValue.Type;
-import org.apache.hadoop.hbase.client.Delete;
-import org.apache.hadoop.hbase.client.Put;
-import org.apache.hadoop.hbase.coprocessor.BaseRegionObserver;
-import org.apache.hadoop.hbase.coprocessor.ObserverContext;
-import org.apache.hadoop.hbase.coprocessor.RegionCoprocessorEnvironment;
-import org.apache.hadoop.hbase.regionserver.compactions.CompactionRequest;
-import org.apache.hadoop.hbase.regionserver.wal.WALEdit;
-import org.apache.hadoop.hbase.themis.columns.ColumnUtil;
-import org.apache.hadoop.hbase.util.Bytes;
-
-public class ThemisRegionObserver extends BaseRegionObserver {
-  public static final String SINGLE_ROW_PRIMARY_QUALIFIER = "_themisSingleRowPrewritePrimaryQualifier_";
-  public static final String LOCK_FAMILY_DELETE = "_themisLockFamilyDelete_";
-  
-  private static final Log LOG = LogFactory.getLog(ThemisRegionObserver.class);
-  
-  @Override
-  public void postFlush(ObserverContext<RegionCoprocessorEnvironment> e, Store store,
-      StoreFile resultFile) throws IOException {
-    if (isLockFamilyStore(store)) {
-      cacheStoreFileBlockByScan(resultFile, true);
-    }
-  }
-  
-  @Override
-  public void postCompact(final ObserverContext<RegionCoprocessorEnvironment> c, final Store store,
-      StoreFile resultFile, CompactionRequest request) throws IOException {
-    if (isLockFamilyStore(store)) {
-      cacheStoreFileBlockByScan(resultFile, false);
-    }
-  }
-  
-  protected static boolean isLockFamilyStore(final Store store) {
-    return Bytes.equals(ColumnUtil.LOCK_FAMILY_NAME, store.getFamily().getName());
-  }
-  
-  protected static void cacheStoreFileBlockByScan(final StoreFile storeFile, boolean isFlush) throws IOException {
-    long startTs = System.currentTimeMillis();
-    long kvCount = 0;
-    StoreFileScanner scanner = null;
-    try {
-      scanner = StoreFileScanner.getScannersForStoreFiles(
-        Collections.singleton(storeFile), true, false).get(0);
-      // seek to head
-      scanner.seek(KeyValue.LOWESTKEY);
-      KeyValue kv = null;
-      while ((kv = scanner.next()) != null) {
-        ++kvCount;
-      }
-    } finally {
-      if (scanner != null) {
-        scanner.close();
-      }
-      LOG.info("flush or compaction file cache for lock family, isFlush=" + isFlush
-          + ", consume(ms)=" + (System.currentTimeMillis() - startTs) + ", kvCount=" + kvCount);
-    }
-  }
-  
-  @Override
-  public void prePut(final ObserverContext<RegionCoprocessorEnvironment> c, final Put put,
-      final WALEdit edit, final boolean writeToWAL) throws IOException {
-    byte[] primaryQualifier = put.getAttribute(SINGLE_ROW_PRIMARY_QUALIFIER);
-    if (primaryQualifier != null) {
-      HRegion region = c.getEnvironment().getRegion();
-      List<KeyValue> kvs = put.getFamilyMap().get(ColumnUtil.LOCK_FAMILY_NAME);
-      if (kvs.size() != put.size() || kvs.size() == 0) {
-        throw new IOException(
-            "contain no-lock family kvs when do prewrite for single row transaction, put=" + put);
-      }
-
-      Store lockStore = region.getStore(ColumnUtil.LOCK_FAMILY_NAME);
-      long addedSize = 0;
-      
-      // we must make sure all the kvs of lock family be written to memstore at the same time,
-      // if not, secondary lock kvs might be written firstly, snapshot and flushed while primary
-      // kv not, which will break the atomic of transaction if region server is crashed before
-      // primary kv flushed(although this seems won't cause problem single row transaction of themis)
-      lockStore.lock.readLock().lock();
-      try {
-        // we must write lock for primary firstly
-        int primaryIndex = -1;
-        for (int i = 0; i < kvs.size(); ++i) {
-          if (Bytes.equals(primaryQualifier, kvs.get(i).getQualifier())) {
-            primaryIndex = i;
-          }
-        }
-
-        if (primaryIndex < 0) {
-          throw new IOException("can't find primary for single row transaction, primaryQualifier="
-              + Bytes.toString(primaryQualifier) + ", put=" + put);
-        }
-
-        kvs.get(primaryIndex).setMemstoreTS(0); // visible by any read
-        addedSize += lockStore.memstore.add(kvs.get(primaryIndex));
-
-        // then, we write secondaries' locks
-        for (int i = 0; i < kvs.size(); ++i) {
-          if (i != primaryIndex) {
-            kvs.get(i).setMemstoreTS(0);
-            addedSize += lockStore.memstore.add(kvs.get(i));
-          }
-        }
-      } finally {
-        lockStore.lock.readLock().unlock();
-      }
-      // TODO : we don't do requestFlush judge here because lock family's write only take small part
-      //        of memory. There is a corner case when there are only prewrites for single row transaction,
-      //        we need to avoid memstore exceeds upper bound in this situation
-      // TODO : keep region size consistent with memestore size(move to finally)
-      region.addAndGetGlobalMemstoreSize(addedSize);
-      c.bypass();
-    }
-  }
-  
-  @Override
-  public void postDelete(final ObserverContext<RegionCoprocessorEnvironment> c,
-      final Delete delete, final WALEdit edit, final boolean writeToWAL) throws IOException {
-    if (isLockFamilyDelete(delete)) {
-      KeyValue deleteKv = delete.getFamilyMap().get(ColumnUtil.LOCK_FAMILY_NAME).get(0);
-      KeyValue dataKv = constructLockKvWithoutValue(deleteKv);
-      dataKv.setMemstoreTS(0);
-
-      HRegion region = c.getEnvironment().getRegion();
-      Store store = region.getStore(ColumnUtil.LOCK_FAMILY_NAME);
-      MemStore memstore = store.memstore;
-      store.lock.readLock().lock();
-      try {
-        // If the key is in the memstore, delete it. Update this.size.
-        boolean removeDataKv = false;
-        Iterator<KeyValue> iter = memstore.kvset.tailSet(dataKv, true).iterator();
-        while (iter.hasNext()) {
-          KeyValue nextkv = iter.next();
-          // comparison without memstore
-          if (dataKv.equals(nextkv)) {
-            if (nextkv.getType() == Type.Delete.getCode()) {
-              removeKvFromKvSet(region, memstore, nextkv);
-            } else {
-              if (removeDataKv) {
-                throw new IOException("exist two lock kv with the same timestamp, nextKv=" + nextkv);
-              }
-              removeKvFromKvSet(region, memstore, nextkv);
-              removeDataKv = true;
-            }
-          } else {
-            break;
-          }
-        }
-
-        if (removeDataKv) {
-          removeKvFromKvSet(region, memstore, deleteKv);
-        }
-      } finally {
-        store.lock.readLock().unlock();
-      }
-    }
-  }
- 
-  protected void removeKvFromKvSet(final HRegion region, final MemStore memstore, KeyValue kv) {
-    if (memstore.kvset.remove(kv)) {
-      long kvSize = memstore.heapSizeChange(kv, true);
-      memstore.size.addAndGet(-kvSize);
-      region.addAndGetGlobalMemstoreSize(-kvSize);
-      memstore.setOldestEditTimeToNow();
-    }
-  }
-  
-  protected static final boolean isLockFamilyDelete(final Delete delete) {
-    return delete.getAttribute(LOCK_FAMILY_DELETE) != null
-        && Bytes.toBoolean(delete.getAttribute(LOCK_FAMILY_DELETE));
-  }
-  
-  protected static KeyValue constructLockKvWithoutValue(final KeyValue deleteKv) {
-    return new KeyValue(deleteKv.getRow(), deleteKv.getFamily(), deleteKv.getQualifier(),
-        deleteKv.getTimestamp(), Type.Put);
-  }
-}